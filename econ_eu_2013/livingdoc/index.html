<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Living Documentation</title>

		<meta name="description" content="Living documentation">
		<meta name="author" content="Alex Lagarde / Mélanie Bats">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
		<link rel="stylesheet" href="css/custo.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<aside class="notes">
					MEB : My purpose today is to share with you our motivation to develop and use a living documentation tool. At the beginning of this project, our need was to improve the documentation existing on a software project we are developping at Obeo, which is named UML Designer. At that time, this project was poorly documented. There was no specification, it only exists some unit and UI tests and some user documentation. Our need was to write a specification that will be useful during the all project lifecycle.
					</aside>
					<h1>Living Documentation</h1>					
					<img src="img/livingdoc-01.jpg" style="border:0px solid black;width:650px"/>
					<h4>Alex Lagarde, Mélanie Bats / Obeo</h4>
				</section>

				<section>
					<aside class="notes">
					MEB : Most of the time in software projects, documentation is a sloppy task. The problem is that many developpers don't like to write documentation. Often they does not have time to write it. When they take or have the time to do it, they feel like if they are loosing their time, as they know that this documentation will never be updated later. That's completly true, spending time to write a documentation that will never be updated is useless! As developper we pay attention to write and maintain tests up to date but it is not the case for the documentation. Updating the documentation is considered as a boring task. You have to open another software, to edit the documentation and then you have to find manually which parts of the documentation should be updated. How could we improve this in order that the documentation become more easy to maintain up to date?
					</aside>
					<h2>The reality</h2>
					<p>
						Write once...and never look at again
						<ul>
							<li>Writing documentation = loosing my time</li>
							<li>Updating documentation = boring task</li>
						</ul>
					</p>
					<img src="img/wasted_paper.jpg" style="border:0px solid black;width:600px"/>
				</section>

				<section>
					<aside class="notes">
					MEB : When I start working on this, my idea was to find a way to make my specification & the tests evolving hand in hand. The main problem was that all the different artifacts of a software project (code, tests, requirements) have NOT the SAME LIFECYCLE. The different persons working on a project could update the different artifacts independently. But this generates outdated documents regarding the code and the tests. What good is a requirement if when you change it you cannot retrieve which functional test should be updated? What I need is a tool to cross-link & synchronize all the project's artifacts to get a consistent documentation at any moment.
					</aside>
					<h2>The theory</h2>
					<p>
						Continue to evolve to get a consistent documentation
					</p>
					<!-- arrow circle -->
					<img src="img/livingdoc-07.jpg" style="border:0px solid black;width:600px"/>
				</section>

				<section>
					<aside class="notes">
					MEB : I want a referential containing all the information of my project in a single place in order that anybody involved in the software could find easily what he looks for whether he searchs for requirements, tests, implementation details or architecture explanation. 
					</aside>
					<h2>Our expectation</h2>
					<p>
						Single source of truth to share the understanding
					</p>
					<img src="img/truth.jpg" style="border:0px solid black;width:600px"/>
				</section>

				<section>
					<aside class="notes">
					MEB : As developpers,  we are used to write Java tests. Theses tests are written to test the code we developped.
					</aside>
					<h2>We are testing</h2>
					<p>
						Developpers are used to write unit tests but...
					</p>
					<img src="img/testing.jpg" style="border:0px solid black"/>
				</section>

				<section>
					<aside class="notes">
					MEB : In fact what we want is not to test the code but we want to validate the behaviour of the software. This means that everyone should be able to understand and participate to the tests : Developpers or end users.
					</aside>
					<h2>Everyone should participate</h2>
					<p>
						Testing is not only matter of developpers
					</p>
					<img src="img/everybody.jpg" style="border:0px solid black"/>
				</section>

				<section>
					<aside class="notes">
					MEB : In UML Designer project I already had many unit tests written in Java. Today these tests are understandable only by Java developpers. Our purpose is to get a kind of map of the different features of the software. How these features are linked to the test? What is implemented or not and is it well tested or not ? This means that the tests must be understandable by anybody, developpers, testers, and any other stakeholders... So we choose to change the focus of the tests, to turn our computer focused tests into human focused documentation.
					</aside>
					<h2>Change focus</h2>
					<p>
						Turn <b>computer</b>-focused <b>tests</b>
					</p>
					<p>
						into <b>human</b>-focused <b>documentation</b>
					</p>
					<img src="img/robot_to_human.jpeg" style="border:0px solid black;width:600px"/>
				</section>

				
				<section>
					<aside class="notes">
					MEB : So I searched a solution to write my project specification. I had a look at what already exists in this domain. As I already heared many things about acceptance testing and executable specification. I take a look on behaviour driven development. BDD is a software development process based on test driven development. It explains how software development should be managed by both business interests and technical insight. As we are not doing TDD on this project, and as our main purpose is to specify the behavoiur of ou software we decided to introduce BDD as process development for UML Designer.
					</aside>
					<h2>Inspiration</h2>
					<p>
						Acceptance testing
					</p>
					<p>
						BDD
					</p>
					<p>
						Executable specification
					</p>
				</section>
				<section>
					<aside class="notes">
					MEB : When I start writing the specification, I need to identify, what were the main features of my software. The first step for me was to clarify who are my end-users. I used personas for this. A persona is a fictional person that represents a group of users. Using personas help me to define which features are the main important ones and consequently where we have to focus our effort. Thanks to this we know what our software must do but how these desired behavior should be specified?
					</aside>
					<h2>Specification by example</h2>
					<p>
						Persona
					</p>					
					
					<!-- personn -->
					<img src="img/livingdoc-02.jpg" style="border:0px solid black;width:650px"/>
				</section>
				<section>
					<aside class="notes">
					MEB : Next step was to find a way to describe these features in order then to re-use the information to generate the tests. According to BDD, we decided to keep 3 different concepts : feature, story and scenario. The features are logical groups of stories. A story specifies who is the stakeholder, which effects it should cause and what business value the stakeholder will get from this effect. A scenario is an acceptance tests used to determine if a requirement is met. Thanks to this process, all the features of our software must be described and linked to acceptance tests. We use the Gherkin syntax to formalize, the acceptance criterias. It starts by specifying the initial context, then defines which triggers start the scenario and finally describes the expected effects. 
					</aside>
					<h2>BDD</h2>
					<p>
						Feature
					</p>
					<p>
						Story (As, I want, So that) 
					</p>					
					<p>
						Scenario (Gherkin)
					</p>
					<div class="intent_content" style="padding-left:15px;font-size:28px">
						<b class="kw">Feature:</b> <b>Password management</b>
						<p><b class="kw">Scenario:</b> <b>Forgot password</b></p>
						<p><b class="kw">Given</b> a user with email "cukes@cukes.info" exists</p>
    						<p><b class="kw">When</b> I ask for a password reset</p>
   						<p><b class="kw">Then</b> an email with a password reset link should be sent</p>
					</div>
				</section>

				<section>
					<aside class="notes">
					MEB : The last but not least point for us, is to keep the documentation, the code and the tests up-to-date. As relying only on person is not sufficient to keep all these artifacts alive, we were looking for tools to help us on this task. We searched a BDD framework that allows to synchronize all the artifacts of a project.
					</aside>
					<h2>Living documentation</h2>
					<p>
						Keep doc, code & tests up-to-date
					</p>
					<img src="img/livingdoc-01.jpg" style="border:0px solid black;width:500px"/>

				</section>
				
				<section>
					<aside class="notes">
					MEB : First I tried Cucumber as it is the most used BDD framework, it is mostly used by web application developpers.
					</aside>
					<h2>Had a look on...</h2>
					<p>
						Cucumber = the most used BDD framework
					</p>
					<img src="img/cucumber.png" style="border:0px solid black;background-color:white;width:500px"/>
				</section>
				<section>
					<aside class="notes">
					MEB : But, as the code of the application is written in Java, I tried JBehave which is an equivalent to cucumber but adapted to Java code. The problem with JBehave is that the scenario definition is still to close to the Java code and we want that anybody could understand the tests. Moreover, we might use this solution also to document non Java projects.
					</aside> 
					<h2>Had a look on...</h2>
					<p>
						JBehave = adapted for java
					</p>
					<img src="img/jbehave1.png" style="border:0px solid black;background-color:white;width:400px"/>
					<img src="img/jbehave2.png" style="border:0px solid black;background-color:white;width:400px"/>
					<img src="img/jbehave3.png" style="border:0px solid black;background-color:white;width:400px"/>
				</section>

				<section>
					<aside class="notes">
					MEB : Another solution could be Jnario. Jnario is also a cucumber like software to write concise tests to document the behaviour of Java programs. It is well integrated to JUnit and Eclipse. It automatically generates the Java tests code from the specification. The problem is that, to test our project we have different kind of tests : unit, plugin and UI tests. These tests run with different kind of launchers, and as for UI tests we are using SWTBot, it is possible but not simple to integrate it to Jnario. Even more important, we need a way to synchronize not only specification and tests but also other kind of project artifacts (User documentation, Sirius specification...). Another problem for us is that with Jnario you have to update the documentation to update the tests. And we wnat to keep different lifecycle for code and documentation.
					</aside>
					<h2>Gave a try to...</h2>
					<p>
						Jnario = well integrated to Eclipse
					</p>
					<img src="img/jnario.png" style="border:0px solid black;background-color:white;width:500px"/>
				</section>

				<section>
					<aside class="notes">
					MEB : We decided to develop our own tool but inspired by all the previous ones I described. We keep the Gherkin syntax to make test writing accessible to functional users. Then our idea was to generate the code from the test specifications. We need also to be able to link the specifications with any other kind of artifacts not only code. And the most important point, we need to known when one of these artifacts has to be updated.
					</aside>
					<h2>Why yet another solution ?</h2>
					<ul>
						<li>Not accessible to Functional users</li>						
						<li>Generate code from test specifications</li>						
						<li>Link specs with other artifacts</li>
						<li>Know when documentation or tests should be updated</li>
					</ul>
				</section>
				<section>
					<aside class="notes">						
						That is exactly why we created Mylyn Intent: to provide tooling for keeping your documentation up-to-date whith the changes you made on
						your software. <br/>
						In a nutshell, Intent Mylyn Intent is a documentation environment integrated to the Eclipse IDE. Providing tooling for 
						keeping your doc up-to-date with any kind of technical arfifact (whether it's java or C++ code, models, plug-in dependencies, a code
						sample on the Internet...).<br/>
						Following the Eclipse mantra "Be extensible, be integrated", you will be able to customize Intent to fit your own devlopment
						processes (by defining custom validation rules for example).
						<br/>
						Intent is part of Eclipse release train since Juno
						under the Mylyn Docs component.<br/>				
					</aside>
					<h2>Mylyn Intent: keep doc synchronized</h2>
					<p>		
						<ul><li>A documentation environment
						<ul style="list-style-type: circle">
							<li>synchronized with artifacts</li>
							<li>customizable for your processes</li>
						</ul></li>
						<li>Part of Mylyn docs since Juno</li></ul>
						<br/><br/>
						<img src="img/intent_logo.png" style="position:relative;top:-20px;width:450px;background:none;border:0px solid black;"/>
						
			
					</p>
				</section>
				<section data-transition="fade" data-transition-speed="slow" class="bgImg" style="background:url(img/intent_linked_doc01.png);background-size:90%;height:82%;background-repeat:no-repeat;background-color:white; background-position:60px 0px;">
					<aside class="notes">
						To keep doc synchronized, what do we need? Well we need a simple and generic mechanism allowing to link documentation parts with
						any kind of technical artifact (Java or C++ code, models, plug-in dependencies...).
					</aside>
				</section>
				<section data-transition="fade" data-transition-speed="slow" class="bgImg" style="background:url(img/intent_linked_doc02.png);background-size:90%;height:82%;background-repeat:no-repeat;background-color:white; background-position:60px 0px;">
					<aside class="notes">
						Why? Because thanks to these formal links...
					</aside>
				</section>
				<section data-transition="fade" data-transition-speed="slow" class="bgImg" style="background:url(img/intent_linked_doc03.png);background-size:90%;height:82%;background-repeat:no-repeat;background-color:white; background-position:60px 0px;">
					<aside class="notes">
						... It is straightforward to determine which little documentation parts needs to be updated when we change any artifact.<br/>
						Thanks to this mechanism, your doc is now able to quickly react to changes, turning it into a true Agile documentation.
					</aside>
				</section>
				<section class="bgImg" style="background:url(img/intent_instead_of.png);background-size:90%;height:82%;background-repeat:no-repeat;background-color:white; background-position:60px 10px;">
					<aside class="notes">
						Very simply, this is how we did it in Intent: instead of having many documentation files on side, and many technical artifact
						on the other side, with no links between them...
					</aside>
				</section>
			
				<section data-transition="fade" data-transition-speed="slow">
					<aside class="notes">
						You get one single Intent document linking documentation & artifacts.
						As you can see, an Intent Document is structured like any documentation (in contains chapter, sections, sub-sections...).
						It contains both pure documentation zones & formal links zones.
					</aside>
					<h2>One Single Intent Document</h2>
					<ul>
						<li>Pure documentation zones</li>
						<li> Formal links zones<br/><br/></li>
					</ul>
					<div class="intent_content" style="padding-left:15px;font-size:28px">
						<b class="kw">Chapter</b> <b>Significant Scenarios</b> {
								<p>
									This chapter specifies the software behavior by listing relevant scenarios.<br/>
								
								<br/><b class="kw">Section</b> <b>Scenario 01: Filtering Offers</b> {</p>
										<p>
											When I select the <i style="color:blue">"Books"</i> in the Category Page,
											I should only see the offers associated to this <i>_category_</i>.
										</p>
										<div class="intent_modelingunit" style="border: 1px solid grey;font-size:26px;margin-left:50px;margin-right:50px;padding-left:10px;">
											<b class="kw">@M</b><br/>
												<b class="kw" style="padding-left:50px">@ref</b><span style="color:blue"> "my.test.project/src/my/test/project/Scenario01Test.java"</span><br/>
											<b class="kw">M@</b>
										</div>
								<p>}</p>
							}
					</div>
				</section>
				<section data-transition="fade" data-transition-speed="slow">
					<aside class="notes">
						Let's first take a look at the pure documentation zones. They are explanations in Natural langage, expressed using the textile 
						syntax. Textile is wildly used within the eclipse community, if you do not know it we will give you a brief overview during demo.
					</aside>
					<h2>One Single Intent Document</h2>
					<ul>
						<li>Pure documentation zones</li>
						<ul style="list-style-type: circle">
							<li>Explanations in Natural language</li>
							<li>Use the Textile syntax</li>
						</ul>
					</ul>
					<div class="intent_content" style="padding-left:15px;font-size:28px">
						<b class="kw">Chapter</b> <b>Significant Scenarios</b> {
								<p>
									This chapter specifies the software behavior by listing relevant scenarios.<br/>
								
								<br/><b class="kw">Section</b> <b>Scenario 01: Filtering Offers</b> {</p>
										<p>
											When I select the <i style="color:blue">"Books"</i> in the Category Page,
											I should only see the offers associated to this <i>_category_</i>.
										</p>
										<div class="intent_modelingunit" id="blur" style="border: 1px solid grey;font-size:26px;margin-left:50px;margin-right:50px;padding-left:10px;">
											<b class="kw">@M</b><br/>
												<b class="kw" style="padding-left:50px">@ref</b><span style="color:blue"> "my.test.project/src/my/test/project/Scenario01Test.java"</span><br/>
											<b class="kw">M@</b>
										</div>
								<p>}</p>
							}
					</div>
				</section>
				<section data-transition="fade" data-transition-speed="slow">
					<aside class="notes">
						And, in addition to these pure documentation zones, the Intent documetn also contains formal links zones. This is these zones that 
						allow us to reference technical arftifacts. Notice that the behavior of those zones is highly customizable: you can change the 
						way they are displayed in the Intent editor, change the behavior of the hyperlinks, plug custom validation rules on the referenced
						artifacts...
					</aside>
					<h2>One Single Intent Document</h2>
					<ul>
						<li>Formal links zones</li>
						<ul style="list-style-type: circle">
							<li>Reference to technical artifacts (Java, model...)</li>
							<li>Extensible behavior (display, hyperlinks, validation...)</li>
						</ul>
					</ul>
					<div class="intent_content" style="padding-left:15px;font-size:28px">
						<div id="blur">
						<b class="kw">Chapter</b> <b>Significant Scenarios</b> {
								<p>
									This chapter specifies the software behavior by listing relevant scenarios.<br/>
								
								<br/><b class="kw">Section</b> <b>Scenario 01: Filtering Offers</b> {</p>
										<p>
											When I select the <i style="color:blue">"Books"</i> in the Category Page,
											I should only see the offers associated to this <i>_category_</i>.
										</p>
										</div>
										<div class="intent_modelingunit" style="border: 1px solid grey;font-size:26px;margin-left:50px;margin-right:50px;padding-left:10px;">
											<b class="kw">@M</b><br/>
												<b class="kw" style="padding-left:50px">@ref</b><span style="color:blue"> "my.test.project/src/my/test/project/Scenario01Test.java"</span><br/>
											<b class="kw">M@</b>
										</div>
								<div id="blur"><p>}</p>
							}</div>
					</div>
				</section>
				<section>
					<aside class="notes">
						ALA : 
					</aside>
					<h2>Living Doc toolchain</h2>
					<p>
						TODO schema
					</p>
				</section>
				<section>
					<aside class="notes">
						ALA : But enough with the chit-chat, let's see how this Living Documentation tool works on a concrete example.
						ALA : environement description
					</aside>
					<h2>Living Doc in Action : Environment</h2>
					<p>
						<ul>
							<li>Eclipse Kepler SR1</li>
							<li>Mylyn Intent 0.9</li>
							<li>Living Doc bridge for Intent</li>
							<li>A "magic filler" plugin (because I'm lazy)</li>		
						</ul>
						<!-- Cinema clap -->
						<img src="img/livingdoc-03.jpg" style="border:0px solid black;width:500px"/>
					</p>
				</section>
				
				<section>
					<aside class="notes">
						MEB: In the demo, we will show you part of the UML Designer specification. We demonstrate how to specify a new feature in the Intent document. Then, we will generate the test structure from the specification and finally we show the synchronization mechanism. So let's start the demo.
					</aside>
					<h2>Living Doc in Action : Scenario</h2>
					<p>
						<ul>	
							<li>Specify the features, stories and scenarios</li>		
							<li>Link the specifications with:</li>
							<ul>
								<li>the Java tests</li>
								<li>the Sirius specification model</li>
							</ul>
							<li>Generate test code</li>
							<li>Iterate by updating code, specification or tests</li>
						</ul>
						<!-- Cinema clap -->
						<img src="img/livingdoc-03.jpg" style="border:0px solid black;width:500px"/>
					</p>
				</section>
				
				<section>
					<aside class="notes">
						ALA:  Demo doc edition
					</aside>
					<h2 style="background-color:white;color:black">Doc edition</h2>
					<h3>Mylyn Intent</h3>
						<ul>
							<li>Loading off your brain (only see doc you need)</li>
							<li>Customizable</li>
							<li>Textile syntax (completion)</li>
						</ul>
					<p><br/>
						&rarr; Let's specify a new feature for UML Designer
					</p>
				</section>
				<section>
					<aside class="notes">
						MEB:  Now we add a new scenario in the Intent document thanks to the Gherkin syntax.
					</aside>
					<h2 style="background-color:white;color:black">Defining Scenarios</h2>
					<h3>Living doc bridge</h3>					
					<ul>
						<li>Simple syntax for executable specs (Gherkin)</li>
						<li>Additional completion</li>					
					</ul>
				</section>
				<section>
					<aside class="notes">
						ALA: Demo links & parse
					</aside>
					<h2 style="background-color:white;color:black">Toward executable scenarios</h2>
					<h3>Living doc bridge</h3>
					<ul>							
						<li>creates links from doc to tests (warning if not exist)</li>
						<li>parse a Specification model out of documentation</li>
					</ul>
					
					<p><br/>
						&rarr; Let's generate the tests from Spec model
					</p>
				</section>
				<section>
					<aside class="notes">
						ALA:  ???
					</aside>
					<h2 style="background-color:white;color:black">Generating tests</h2>
					<h3>Living doc generator</h3>
					<ul>
						Use doc to generate test code structure
					</ul>
					<p><br/>
						&rarr; Let's try to navigate from doc to code
					</p>
				</section>
				<section>
					<aside class="notes">
						ALA:  ???
					</aside>
					<h2 style="background-color:white;color:black">Cross-linked documentation</h2>
					<h3>Mylyn Intent</h3>					
					<ul>							
						<li>Hyperlinks to navigate from doc to code</li>
						<li>Quick-outline to retrieve doc parts related to an artifact</li>
					</ul>
					<p><br/>
						&rarr; Let's take a look at the warning
					</p>
				</section>
				<section>
					<aside class="notes">
						ALA:  ???
					</aside>
					<h2 style="background-color:white;color:black">Advanced validation</h2>	
					<h3>Living doc bridge</h3>									
					<ul>							
						<li>Custom validation rules</li>
						<li>Custom quick-fixes</li>
					</ul>
					<p><br/>
						&rarr; Let's link new elements
					</p>
				</section>
				<section>
					<aside class="notes">
						MEB:  In conclusion, you have no more reason, to let your documentation die! Thanks to Mylyn Intent it's easy to link the different artifacts to your documentation. Thanke to the synchronization mechanism, you can decide to update the documentation when you want, you can find when an artifacts was modified which part of the documentation should be updated.
					</aside>
					<h2 style="background-color:white;color:black">Live and not let die</h2>					
						<ul>							
							<li>Drag and drop artifacts inside doc</li>
							<li>Deciding when to update the doc is up to you</li>
							<li>Extensible synchronization
							<ul>
							<li>Modify the Sirius specification model &rarr; update specs or rollback</li>
							<li>Modify a Java test &rarr; update specs or rollback</li>
							<li>Modify the specifications &rarr; update tests or rollback</li>
							</ul></li>
						</ul>
				</section>

				<section>
					<h2>What's cooking?</h2>
					<p>
						<ul>
							<li>Stabilisation & performances</li>
							<li>Project managment diagram: visualize
								<ul>
									<li>What's documented?</li>
									<li>What's tested?</li>
									<li>What's outdated?</li>
								</ul>
							</li>
							<li>New synchronization bridges FTW (builds, bug tracker...)</li>
						</ul>
					</p>
					<!-- casserole -->
					<img src="img/livingdoc-04.jpg" style="border:0px solid black;width:500px"/>
				</section>

				<section>
					<h2>Remember : Living doc, it's alive!</h2>
					<ol>
						<li>Everybody can participate to tests</li>
						<li>Doc up-to-date with concrete world</li>
						<li>Customizable to your needs</li>
					</ol>
					<img src="img/frankenstein.jpg" style="border:0px solid black;width:500px"/>
				</section>
				<section>
					<h2>Disclaimer</h2>
					<p>Only one (especially crappy) book was harmed during the preparation of this talk</p>
					<!-- thumb up/ raising hands -->
					<img src="img/livingdoc-05.jpg" style="border:0px solid black;width:500px"/>
				</section>

				<section>
					<h2>Don't miss Sirius talks</h2>
					<ul>
						<li>Wednesday
							<ul>
								<li>14:30 - Changing the Game of Systems Architecture</li>
								<li>16:15 - Sirius By Example</li>
								<li>17:00 - EcoreTools 2.0: The Making Of</li>
								<li>19:00 - BOF "Let's get Sirius"</li> 
							</ul>
						</li>
						<li>At any time: ask us or visit Obeo booth</li>
					</ul>
					<img src="img/logo_Sirius.png" style="border:0px solid black;width:300px"/>
				</section>

				
				<section>
					<h1>Thanks!</h1>
					<!-- thumb up/ raising hands -->
					<img src="img/livingdoc-06.jpg" style="border:0px solid black;width:500px"/>
				<h4 style="background-color:white;margin:50px;color:black;padding:0px;">Don't forget to give feedback <img src="img/feedback.png" style="padding-left:50px;padding-right:50px;margin-top:-20px;position:relative;top:20px;width:150px;border:0px solid black;"/></h4>
						
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
